## 切片

### slice01.go
主要介绍了切片的基本使用

1.创建切片的三种方式

注意:make([]int,10)和make([]int ,0,10)的区别

2.切片扩容的机制

- 扩容操作只关心容量，会把原Slice数据拷贝到新Slice，追加数据由append在扩容结束后完成。
- 原Slice容量小于1024，则新Slice容量将扩大为原来的2倍； 原Slice容量大于等于1024，则新Slice容量将扩大为原来的1.25倍。

3.切片拷贝
- copy 函数支持在不同长度的 Slice 之间进行复制，若出现长度不一致，在复制时会按照最少的 Slice 元素个数进行复制。 
- 生成一个新的切片

4.遍历切片
- range 的方式去遍历一个切片，拿到的 Value 其实是切片里面的值拷贝。所以每次打印 Value 的地址都不变。由于 Value 是值拷贝的，并非引用传递，所以直接改 Value 是达不到更改原切片值的目的的，需要通过 &a[i] 获取真实的地址。
- 所有被遍历的键值对将被赋值给同一对循环变量实例。


### slice_02.go
使用切片时应该注意的地方

**特别注意func4方法**

总结
- 创建切片时可根据实际需要预分配容量，尽量避免追加过程中扩容操作，有利于提升性能
- 谨慎使用多个切片操作同一个数组，以防读写冲突
- 切片作为函数传参是值传递，**拷贝了一个新的切片，指向了同原切片的底层数组。**所以修改函数的切片，会影响外面的切片。
- 当slice作为函数参数时，如果在函数内部发生了扩容，这时再修改 slice 中的值是不起作用的，因为修改发生在新的 array 内存中，对老的 array 内存不起作用。
- 通过函数传递切片时，不会拷贝整个切片，因为切片本身只是个结构体而矣。
- 使用 append() 向切片追加元素时有可能触发扩容，扩容后将会生成新的切片
- 对有初始化的和没有初始化的切片，序列化是不一样的